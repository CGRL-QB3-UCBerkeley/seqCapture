#!/usr/bin/env perl
use warnings;
use strict;
use Getopt::Std;

die (qq/

Usage: seqCapture snpcleaner  [options]


-f     FILE     reference fasta
-b     DIR      bam folder
-r     DIR      result dir
-t     FILE     a list of extremely high coverage sites to be removed 
                (in keep format, generated by seqCap prefilter)
-k     INT      Min number of individuals with less than -u INT coverage 
-u     INT      Minimum individual coverage threshold used in -k
-Q     INT      Minimum RMS mapping quality for SNPS [10]
-S     FLOAT    Min p-value for strand bias [0.0001] ## must be 0 for RAD data
-q     FLOAT    Min p-value for base quality bias [1e-100]
-F     FLOAT    Min p-value for map quality bias [0]
-e     FLOAT    Min p-value for end distance bias [0.0001] muse be 0 for RAD data
-h     FLOAT    Min p-value for exact test of HWE [1e-4]
-H     FLOAT    Min p-value for exact test of excess of heterozygous [0]
-L     FLOAT    Min p-value for exact test of defect of heterozygous [0]
-l     INT      Remove SNPs\/sites within l bp upstream and downstream 
                around an INDEL [10]

    
\n/) if !@ARGV;

my %opts = (t=>undef,  r=>undef, d=>1, D=>10000, k=>undef, u=> undef, Q=>10, S=>0.0001, q=>1e-100 , F=>0, e=>0.0001, h=>1e-4, H=>0, L=>0,l=>10,b=>undef, f=>undef);  
getopts('d:D:k:u:Q:S:q:f:e:h:H:L:l:r:b:F:t:', \%opts);

my $resdir = redir ($opts{r});
mkdir $resdir unless -e $resdir;
my $bamdir = redir ($opts{b}) || die "can not locate bamdir\n";
  
if ($opts{k} !~ m/^\d+$/g || $opts{u} !~ m/^\d+$/g) {
    die(qq/option -k and -u are inter-dependent (min number of -k INT individuals with less than -u INT coverage)\n/);
  }
  my $ref = $opts{f};
  my $raw = $resdir . "raw.vcf";
  system ("samtools mpileup -s -Q 20 -A -t DP,SP -d 100000 -E -ugf $ref $bamdir*bam | bcftools call -c -p 0.1 - > $raw");

  my $d = $opts{k} * $opts{u};
  my $D = $opts{t} or die "need a list of extremely high coverage sites to be removed\n";
  my $bed = filtering ($resdir, $raw, $d, $D, $opts{k}, $opts{u}, $opts{Q}, $opts{S}, $opts{q}, $opts{F}, $opts{e}, $opts{h}, $opts{H}, $opts{L}, $opts{l});




sub redir {
  my ($dir) = @_;
  my $out;
  if ($dir =~ m/\/$/ ){
    $out = $dir; 
  }
  else {
    $out = $dir . "/";
  }
  return ($out);
}


sub filtering {
  my ($refdir, $raw,  $low, $high, $k, $u, $Q, $S, $q, $f, $e, $h, $H, $L, $l)= @_;  
     
  my %contig_to_remove;
  my %bed;
  my %indel;
  my %dump;
  my ($n_sites, $ind_dp, $prev_format, @format, @ind_depth) = (0,0,"");
  my ($prev_contig, $cur_contig, $pos) = ('start','start',0);

  my %highsites;
  open (HIGH, "<", $high);
  while (<HIGH>) {
    chomp (my @a = split /\s+/,$_);
    $highsites{$a[0]}{$a[1]}++;
  }
  close HIGH;
  
  #open some necessary filehandles
  my $bed = $refdir . "Sites_passed_filters.keep";  
  open(KEEP, ">", $bed);
  my $dump = $refdir . "Sites_passed_filters.dumped";
  open(DUMP, ">", $dump);
  
  open (RAW, "<", $raw);
  while (<RAW>) {
    my $violate; # for flagging filter violations
    chomp (my @t = split /\s+/, $_);

    next if ( $t[0] =~ m /^#/);
    
    $pos = $t[1];
    
    if($t[0] ne $cur_contig){
	$prev_contig = $cur_contig;
	$cur_contig = $t[0];
    }
    
    # Skip sites with unknown ref
    $violate .= 'N' if ($t[3] eq 'N');
    
    # Skip non-biallelic Sites
    $violate .= '2' if ($t[4] =~ m/,/); 
    
    $violate .= 'I' if ($t[7] =~ m/INDEL/);

    # Eveness across individuals coverage filter
    # check where in vcf FORMAT the DP ID is	
    if( $prev_format ne $t[8] ){
	$ind_dp = 0;
	$prev_format = $t[8];
	@format = split(":",$t[8]);
	foreach (@format) {
	    $ind_dp++ if($_ ne 'DP'); ## so $ind_dp is offset by 1
	    last if($_ eq 'DP');
	}
    }
    
    my $covcount = 0;
    my @genoinfo = @t[9 .. $#t];
    if( $ind_dp <= $#format ) { # if DP is missing in vcf skip even coverage filter
      for(my $i=0; $i <= $#genoinfo; $i++) {
	my @ind_info = split(":", $genoinfo[$i]);
	$covcount++ if ($ind_info[$ind_dp] >= $u);
	$ind_depth[$i] += $ind_info[$ind_dp];
      }
      $violate .= 'k' if ($covcount <= $k);	
    }
    else {
      warn("WARNING: no individual depth information at ",$cur_contig,", pos ",$pos,". Check for \"samtools mpileup -t DP\" option.");
      print "program is quitting!\n";
      exit;
    }
    
    # Site coverage 
    my ($dp, $dp_alt) = (0,0);
    if ($t[7] =~ m/DP4=(\d+),(\d+),(\d+),(\d+)/i) {
	$dp = $1 + $2 + $3 + $4;
	$dp_alt = $3 + $4;
    }
    
    $violate .= 'd' if ($dp <= $k * $u || $dp <= $low);
    $violate .= 'D' if $highsites{$t[0]}{$t[1]};
    
    my $mq = $1 if ($t[7] =~ m/MQ=(\d+)/i);
    $violate .= 'Q' if ($mq && $mq < $Q);

    # Strand, baseQ, mapQ, and tail distance bias
    my ($strand, $baseqb, $mapqb, $tail_dist);
    if ($t[7] =~ m/PV4=([^,]+),([^,]+),([^,]+),([^,;\t]+)/) {
      $strand = $1;
      $baseqb = $2;
      $mapqb = $3;
      $tail_dist = $4;
    }
    $violate .= 'S' if ($strand && $strand < $S);
    $violate .= 'q' if ($baseqb && $baseqb < $q);
    $violate .= 'f' if ($mapqb && $mapqb < $f);
    $violate .= 'e' if ($tail_dist && $tail_dist < $e);
   
    # HWE exact test
    if ($t[4] ne '.') {
      my %genocount = (homoa => 0, homob => 0, het => 0);
      foreach (@genoinfo) {
	if (/0\/0:/) {
	  $genocount{homoa}++;
	} elsif (/1\/1:/) {
	  $genocount{homob}++;
	} elsif (/0\/1:|1\/0:/) {
	  $genocount{het}++;
	}
      }
      
      my ($pHWE, $pHI, $pLOW) = hwe_exact($genocount{het},$genocount{homoa},$genocount{homob},0);
      
      die(qq/Genotype counts less than 0\n/) if $pHWE == -1;
      
      if ($pHWE < $h) {
	$violate .= "h(p=$pHWE)";
      }
      if ($pHI < $H) {
	$violate .= "H(p=$pHI)";
      }
      if ($pLOW < $L) {
	$violate .= "L(p=$pLOW)";
      }
    } ##if ($t[4] ne '.') 
    

    $bed{$t[0]}{$t[1]}++ if (! $violate); 
    
    if ($violate) {
      $dump{$t[0]}{$t[1]} = $violate;
      
      if ($violate =~ m /[H|L|h]/) {
       $contig_to_remove{$t[0]}++;
      }
      
      if ($violate =~ m /I/) {
	my $maxlen = 0;
        $maxlen = length($t[3]) if length($t[3]) >= length($t[4]);
	$maxlen = length($t[4]) if length($t[3]) < length($t[4]);
	for (my $i = $t[1] - $l;   $i<= $t[1] + $maxlen + $l; $i ++) {
	  $indel{$t[0]}{$i}++;
	}
      }
    } 
  }

  foreach my $contig (sort {$a cmp $b} keys %bed) {
    foreach my $pos (sort {$a <=> $b} keys %{$bed{$contig}} ) {
      unless ($contig_to_remove{$contig}) {
	unless  ($indel{$contig}{$pos} ) {
	  print KEEP $contig, "\t", $pos, "\n";
	}
      }
    }
  }
  close KEEP;
  
  foreach my $contig (sort {$a cmp $b} keys %dump) {
    foreach my $pos (sort {$a <=> $b} keys %{$dump{$contig}} ) {
      print DUMP $dump{$contig}{$pos}, "\t", $contig, "\t", $pos, "\n"; 
    }
  }
  close DUMP;
}



sub hwe_exact {

# Citation:
# Implements an exact SNP test of Hardy-Weinberg Equilibrium as described in Wigginton et al. 2005
# note that probabilities are calculated from the midpoint in order to take advantage of the recurrence
# relationships recognized in Guo and Thompson (1992) in the implementation of their MCMC sampler

    my ($obs_hets, $obs_homa, $obs_homb, $F) = @_;

    return(-1) if ($obs_hets < 0 || $obs_homa < 0 || $obs_homb < 0);

    my $obs_homr; #rare homozygote
    my $obs_homc; #commmon homozygote
    my $n = $obs_homa + $obs_homb + $obs_hets; # total number genotypes

    # define common and rare homozygotes
    if ($obs_homa > $obs_homb) {
	$obs_homc = $obs_homa;
	$obs_homr = $obs_homb;
    } elsif ($obs_homa < $obs_homb) {
	$obs_homc = $obs_homb;
	$obs_homr = $obs_homa;
    } elsif ($obs_homa == $obs_homb) { # need to check how matching number homos affects algorithm
	$obs_homc = $obs_homa;
	$obs_homr = $obs_homb;
    }

    my $rare = 2 * $obs_homr + $obs_hets; # number of minor alleles

    # theta for inbreeding HWE calculations
    my $pc = 1 - $rare/(2*$n);
    my $pr = 1 - $pc;
    my $pCC = $pc**2 + $pc*$pr*$F;
    my $pCR = 2*$pc*$pr - 2*$pc*$pr*$F;
    my $pRR = $pr**2 + $pc*$pr*$F;
    $pRR = 1e-6 if($pRR == 0);
    my $theta = ($pCR**2)/($pCC*$pRR);
    $theta = 1e-6 if($theta == 0);

    # initialize heterozygote probability array
    my @probs;
    for (my $i = 0; $i <= $rare; $i++) {
	$probs[$i] = 0.0;
    }

    # find midpoint of the minor allele count distribution
    my $mid = int($rare * (2 * $n - $rare) / (2 * $n));
    $mid = $mid + 1 if ( ($mid % 2) != ($rare % 2) ); # ensures number minor alleles and midpoint have parity

    my $curr_hets = $mid;
    my $curr_homr = ($rare - $mid) / 2;
    my $curr_homc = $n - $curr_hets - $curr_homr;

    $probs[$mid] = 1.0;
    my $sum = $probs[$mid];

    # calculate probabilities from midpoint down 
    for ($curr_hets = $mid; $curr_hets > 1; $curr_hets -= 2) {
	$probs[$curr_hets - 2] = $probs[$curr_hets] * $curr_hets * ($curr_hets - 1) / 
	    ($theta * ($curr_homr + 1) * ($curr_homc + 1));
	$sum += $probs[$curr_hets - 2];

	# 2 fewer heterozygotes for next iteration -> add one rare, one common homozygote
	$curr_homr++;
	$curr_homc++;
    }

    # calculate  probabilities from midpoint up
    $curr_hets = $mid;
    $curr_homr = ($rare - $mid) / 2;
    $curr_homc = $n - $curr_hets - $curr_homr;

    for ($curr_hets = $mid; $curr_hets <= $rare - 2; $curr_hets += 2) {
	$probs[$curr_hets + 2] = $probs[$curr_hets] * $theta * $curr_homr * $curr_homc /
	    (($curr_hets + 2) * ($curr_hets + 1));
	$sum += $probs[$curr_hets + 2];
	
	# add 2 heterozygotes for next interation -> subtract one rare, one common homozygote
	$curr_homr--;
	$curr_homc--;
    }
    for (my $i = 0; $i <= $rare; $i++) {
	$probs[$i] /= $sum;
    }

    # p-value calculation for hwe
    my $p_hwe = 0.0;
    for (my $i = 0; $i <= $rare; $i++) {
	next if ($probs[$i] > $probs[$obs_hets]);
	$p_hwe += $probs[$i];
    }
    $p_hwe = 1.0 if ($p_hwe > 1);

    # alternate p-value calculation for p_hi/p_low heterozygous
    my $p_hi = $probs[$obs_hets];
    for (my $i = $obs_hets + 1; $i <= $rare; $i++) {
	$p_hi += $probs[$i];
    }
    my $p_low = $probs[$obs_hets];
    for (my $i = $obs_hets - 1; $i >= 0; $i--) {
	$p_low += $probs[$i];
    }
    return($p_hwe, $p_hi, $p_low);
} 

